{"version":3,"sources":["../../src/functions/logging.ts","../../src/functions/block.ts","../../src/functions/logger.ts"],"sourcesContent":["import \"@moonbeam-network/api-augment\";\nimport type { ApiPromise } from \"@polkadot/api\";\nimport { mapExtrinsics } from \"./block\";\nimport type { Extrinsic } from \"@polkadot/types/interfaces\";\nimport { setupLogger as createTestLogger } from \"./logger\";\n\n// Re-export setupLogger from logger.ts for backward compatibility\nexport const setupLogger = createTestLogger;\n\nexport function log(...msg: any[]) {\n  if (process.argv?.[2] && process.argv[2] === \"--printlogs\") {\n    console.log(...msg);\n  }\n}\n\nexport const printTokens = (api: ApiPromise, tokens: bigint, decimals = 2, pad = 9) => {\n  if (!api.registry.chainDecimals[0]) {\n    throw new Error(\"Chain decimals not found for system token\");\n  }\n\n  return `${(\n    Math.ceil(Number(tokens / 10n ** BigInt(api.registry.chainDecimals[0] - decimals))) /\n    10 ** decimals\n  )\n    .toString()\n    .padStart(pad)} ${api.registry.chainTokens[0]}`;\n};\n\nexport const printEvents = async (api: ApiPromise, hash?: string) => {\n  const blockHash = hash || (await api.rpc.chain.getBlockHash()).toString();\n  const apiAt = await api.at(blockHash);\n  const { block } = await api.rpc.chain.getBlock(blockHash);\n  const allRecords = (await apiAt.query.system.events()) as any;\n\n  const txsWithEvents = mapExtrinsics(block.extrinsics as unknown as Extrinsic[], allRecords);\n\n  console.log(`===== Block #${block.header.number.toString()}: ${blockHash}`);\n  console.log(block.header.toHuman());\n  console.log(\n    txsWithEvents\n      .map(\n        ({ extrinsic, events }, i) =>\n          `  [${i}]: ${extrinsic.method.section.toString()}. ` +\n          `${extrinsic.method.method.toString()}\\n` +\n          `  - 0x${Buffer.from(extrinsic.data).toString(\"hex\")}\\n${events\n            .map(\n              (event) =>\n                `    * ${event.section.toString()}.${event.method.toString()}:\\n${event.data\n                  .map((datum) => `      - ${datum.toHex()}`)\n                  .join(\"\\n\")}`\n            )\n            .join(\"\\n\")}`\n      )\n      .join(\"\\n\")\n  );\n};\n","import \"@moonbeam-network/api-augment\";\nimport type { ApiPromise } from \"@polkadot/api\";\nimport type { TxWithEvent } from \"@polkadot/api-derive/types\";\nimport type { Option, u32, u64 } from \"@polkadot/types\";\nimport type { ITuple } from \"@polkadot/types-codec/types\";\nimport type {\n  BlockHash,\n  DispatchError,\n  DispatchInfo,\n  Event,\n  Extrinsic,\n  RuntimeDispatchInfo,\n  RuntimeDispatchInfoV1,\n} from \"@polkadot/types/interfaces\";\nimport type { Block, SignedBlock } from \"@polkadot/types/interfaces/runtime/types\";\nimport type { FrameSystemEventRecord, SpWeightsWeightV2Weight } from \"@polkadot/types/lookup\";\nimport Bottleneck from \"bottleneck\";\nimport { createLogger } from \"./logger\";\nconst logger = createLogger({ name: \"test:blocks\" });\nconst debug = logger.debug.bind(logger);\n\nexport async function createAndFinalizeBlock(\n  api: ApiPromise,\n  parentHash?: string,\n  finalize = false\n): Promise<{\n  duration: number;\n  hash: string;\n  proofSize?: number;\n}> {\n  const startTime: number = Date.now();\n  // TODO: any/raw rpc request can be removed once api-augment is updated\n  const block: any = parentHash\n    ? await api.rpc(\"engine_createBlock\", true, finalize, parentHash)\n    : await api.rpc(\"engine_createBlock\", true, finalize);\n\n  return {\n    duration: Date.now() - startTime,\n    hash: block.hash as string, // toString doesn't work for block hashes\n    proofSize: block.proof_size as number, // TODO: casting can be removed once api-augment is updated\n  };\n}\n\n// Given a deposit amount, returns the amount burned (80%) and deposited to treasury (20%).\n// This is meant to precisely mimic the logic in the Moonbeam runtimes where the burn amount\n// is calculated and the treasury is treated as the remainder. This precision is important to\n// avoid off-by-one errors.\nexport function calculateFeePortions(amount: bigint): {\n  burnt: bigint;\n  treasury: bigint;\n} {\n  const burnt = (amount * 80n) / 100n; // 20% goes to treasury\n  return { burnt, treasury: amount - burnt };\n}\n\nexport interface TxWithEventAndFee extends TxWithEvent {\n  fee: RuntimeDispatchInfo | RuntimeDispatchInfoV1 | undefined;\n}\n\nexport interface BlockDetails {\n  block: Block;\n  txWithEvents: TxWithEventAndFee[];\n}\n\nexport interface BlockRangeOption {\n  from: number;\n  to: number;\n  concurrency?: number;\n}\n\nexport const getBlockExtrinsic = async (\n  api: ApiPromise,\n  blockHash: string | BlockHash,\n  section: string,\n  method: string\n): Promise<{\n  block: SignedBlock | any;\n  extrinsic: Extrinsic | null | any;\n  events: Event[];\n  resultEvent: Event | undefined;\n}> => {\n  const apiAt = await api.at(blockHash);\n  const [{ block }, records] = await Promise.all([\n    api.rpc.chain.getBlock(blockHash),\n    apiAt.query.system.events(),\n  ]);\n  const extIndex = block.extrinsics.findIndex(\n    (ext) => ext.method.section === section && ext.method.method === method\n  );\n  const extrinsic = extIndex > -1 ? block.extrinsics[extIndex] : null;\n  const events = (records as any)\n    .filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(extIndex))\n    .map(({ event }) => event);\n  const resultEvent = events.find(\n    (event) =>\n      event.section === \"system\" &&\n      (event.method === \"ExtrinsicSuccess\" || event.method === \"ExtrinsicFailed\")\n  );\n  return { block, extrinsic, events, resultEvent };\n};\n\nexport const getBlockTime = (signedBlock: any) =>\n  signedBlock.block.extrinsics\n    .find((item) => item.method.section === \"timestamp\")\n    .method.args[0].toNumber();\n\nexport const checkBlockFinalized = async (api: ApiPromise, number: number) => {\n  return {\n    number,\n    //@ts-expect-error - remove once pJs exposes this\n    finalized: await api._rpcCore.provider.send(\"moon_isBlockFinalized\", [\n      await api.rpc.chain.getBlockHash(number),\n    ]),\n  };\n};\n\nconst fetchBlockTime = async (api: ApiPromise, blockNum: number) => {\n  const hash = await api.rpc.chain.getBlockHash(blockNum);\n  const block = await api.rpc.chain.getBlock(hash);\n  return getBlockTime(block);\n};\n\nexport const fetchHistoricBlockNum = async (\n  api: ApiPromise,\n  blockNumber: number,\n  targetTime: number\n) => {\n  if (blockNumber <= 1) {\n    return 1;\n  }\n  const time = await fetchBlockTime(api, blockNumber);\n\n  if (time <= targetTime) {\n    return blockNumber;\n  }\n\n  return fetchHistoricBlockNum(\n    api,\n    blockNumber - Math.ceil((time - targetTime) / 30_000),\n    targetTime\n  );\n};\n\nexport const getBlockArray = async (\n  api: ApiPromise,\n  timePeriod: number,\n  bottleneck?: Bottleneck\n) => {\n  /**  \n  @brief Returns an sequential array of block numbers from a given period of time in the past\n  @param api Connected ApiPromise to perform queries on\n  @param timePeriod Moment in the past to search until\n  @param limiter Bottleneck rate limiter to throttle requests\n  */\n\n  let limiter = bottleneck;\n\n  if (!limiter) {\n    limiter = new Bottleneck({ maxConcurrent: 10, minTime: 100 });\n  }\n  const finalizedHead = await limiter.schedule(() => api.rpc.chain.getFinalizedHead());\n  const signedBlock: SignedBlock = await limiter.schedule(() =>\n    api.rpc.chain.getBlock(finalizedHead)\n  );\n\n  const lastBlockNumber = signedBlock.block.header.number.toNumber();\n  const lastBlockTime = getBlockTime(signedBlock);\n\n  const firstBlockTime = lastBlockTime - timePeriod;\n  debug(`Searching for the block at: ${new Date(firstBlockTime)}`);\n  const firstBlockNumber = (await limiter.wrap(fetchHistoricBlockNum)(\n    api,\n    lastBlockNumber,\n    firstBlockTime\n  )) as number;\n  const length = lastBlockNumber - firstBlockNumber;\n  return Array.from({ length }, (_, i) => firstBlockNumber + i);\n};\n\nexport function extractWeight(\n  weightV1OrV2: u64 | Option<u64> | SpWeightsWeightV2Weight | Option<any>\n) {\n  if (\"isSome\" in weightV1OrV2) {\n    const weight = weightV1OrV2.unwrap();\n    if (\"refTime\" in weight) {\n      return weight.refTime.unwrap();\n    }\n    return weight;\n  }\n  if (\"refTime\" in weightV1OrV2) {\n    return weightV1OrV2.refTime.unwrap();\n  }\n  return weightV1OrV2;\n}\n\nexport function extractPreimageDeposit(\n  request:\n    | Option<ITuple<any>>\n    | {\n        readonly deposit: ITuple<any>;\n        readonly len: u32;\n      }\n    | {\n        readonly deposit: Option<ITuple<any>>;\n        readonly count: u32;\n        readonly len: Option<u32>;\n      }\n) {\n  const deposit = \"deposit\" in request ? request.deposit : request;\n  if (\"isSome\" in deposit && deposit.isSome) {\n    return {\n      accountId: deposit.unwrap()[0].toHex(),\n      amount: deposit.unwrap()[1],\n    };\n  }\n  if (\"isNone\" in deposit && deposit.isNone) {\n    return undefined;\n  }\n  return {\n    accountId: deposit[0].toHex(),\n    amount: deposit[1],\n  };\n}\n\nexport function mapExtrinsics(\n  extrinsics: Extrinsic[],\n  records: FrameSystemEventRecord[],\n  fees?: RuntimeDispatchInfo[] | RuntimeDispatchInfoV1[]\n): TxWithEventAndFee[] {\n  return extrinsics.map((extrinsic, index): TxWithEventAndFee => {\n    let dispatchError: DispatchError | undefined;\n    let dispatchInfo: DispatchInfo | undefined;\n\n    const events = records\n      .filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index))\n      .map(({ event }) => {\n        if (event.section === \"system\") {\n          if (event.method === \"ExtrinsicSuccess\") {\n            dispatchInfo = event.data[0] as DispatchInfo;\n          } else if (event.method === \"ExtrinsicFailed\") {\n            dispatchError = event.data[0] as DispatchError;\n            dispatchInfo = event.data[1] as DispatchInfo;\n          }\n        }\n\n        return event;\n      });\n    return {\n      dispatchError,\n      dispatchInfo,\n      events,\n      extrinsic,\n      fee: fees ? fees[index] : undefined,\n    };\n  });\n}\n\nexport async function checkTimeSliceForUpgrades(\n  api: ApiPromise,\n  blockNumbers: number[],\n  currentVersion: u32\n) {\n  const apiAt = await api.at(await api.rpc.chain.getBlockHash(blockNumbers[0]));\n  const onChainRt = (await apiAt.query.system.lastRuntimeUpgrade()).unwrap().specVersion;\n  return { result: !onChainRt.eq(currentVersion), specVersion: onChainRt };\n}\n","import pino from \"pino\";\nimport type { Logger } from \"pino\";\nimport pinoPretty from \"pino-pretty\";\n\nexport interface LoggerOptions {\n  name: string;\n  level?: string;\n  enabled?: boolean;\n}\n\nconst logLevel = process.env.LOG_LEVEL || \"info\";\n\n// Create pretty stream for all contexts\nconst prettyStream = pinoPretty({\n  colorize: true,\n  translateTime: \"HH:MM:ss.l\",\n  ignore: \"pid,hostname\",\n  sync: true, // Important for worker threads\n});\n\nconst pinoOptions: pino.LoggerOptions = {\n  level: logLevel,\n  formatters: {\n    level: (label) => {\n      return { level: label };\n    },\n  },\n};\n\nconst loggers = new Map<string, Logger>();\n\nexport function createLogger(options: LoggerOptions): Logger {\n  const { name, level = logLevel, enabled = true } = options;\n\n  const existingLogger = loggers.get(name);\n  if (existingLogger) {\n    return existingLogger;\n  }\n\n  const loggerConfig: pino.LoggerOptions = {\n    name,\n    level,\n    enabled,\n    formatters: pinoOptions.formatters,\n  };\n\n  // Create logger with pretty stream\n  const logger = pino(loggerConfig, prettyStream);\n\n  loggers.set(name, logger);\n\n  return logger;\n}\n\nexport function getLogger(name: string): Logger | undefined {\n  return loggers.get(name);\n}\n\nexport function clearLoggers(): void {\n  loggers.clear();\n}\n\n// Helper function to enable/disable specific loggers\nexport function setLoggerEnabled(pattern: string, enabled: boolean): void {\n  const regex = new RegExp(pattern.replace(/\\*/g, \".*\"));\n\n  loggers.forEach((logger, name) => {\n    if (regex.test(name)) {\n      logger.level = enabled ? logLevel : \"silent\";\n    }\n  });\n}\n\n// Compatibility layer for the existing setupLogger function\nexport function setupLogger(name: string): pino.Logger {\n  const logger = createLogger({\n    name: `test:${name}`,\n    enabled: process.argv.includes(\"--printlogs\"),\n  });\n\n  return logger;\n}\n\n// Re-export types\nexport type { Logger } from \"pino\";\n"],"mappings":"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","names":["logger","logger","setupLogger"]}