{"version":3,"sources":["../../src/functions/block.ts","../../src/functions/logger.ts"],"sourcesContent":["import \"@moonbeam-network/api-augment\";\nimport type { ApiPromise } from \"@polkadot/api\";\nimport type { TxWithEvent } from \"@polkadot/api-derive/types\";\nimport type { Option, u32, u64 } from \"@polkadot/types\";\nimport type { ITuple } from \"@polkadot/types-codec/types\";\nimport type {\n  BlockHash,\n  DispatchError,\n  DispatchInfo,\n  Event,\n  Extrinsic,\n  RuntimeDispatchInfo,\n  RuntimeDispatchInfoV1,\n} from \"@polkadot/types/interfaces\";\nimport type { Block, SignedBlock } from \"@polkadot/types/interfaces/runtime/types\";\nimport type { FrameSystemEventRecord, SpWeightsWeightV2Weight } from \"@polkadot/types/lookup\";\nimport Bottleneck from \"bottleneck\";\nimport { createLogger } from \"./logger\";\nconst logger = createLogger({ name: \"test:blocks\" });\nconst debug = logger.debug.bind(logger);\n\nexport async function createAndFinalizeBlock(\n  api: ApiPromise,\n  parentHash?: string,\n  finalize = false\n): Promise<{\n  duration: number;\n  hash: string;\n  proofSize?: number;\n}> {\n  const startTime: number = Date.now();\n  // TODO: any/raw rpc request can be removed once api-augment is updated\n  const block: any = parentHash\n    ? await api.rpc(\"engine_createBlock\", true, finalize, parentHash)\n    : await api.rpc(\"engine_createBlock\", true, finalize);\n\n  return {\n    duration: Date.now() - startTime,\n    hash: block.hash as string, // toString doesn't work for block hashes\n    proofSize: block.proof_size as number, // TODO: casting can be removed once api-augment is updated\n  };\n}\n\n// Given a deposit amount, returns the amount burned (80%) and deposited to treasury (20%).\n// This is meant to precisely mimic the logic in the Moonbeam runtimes where the burn amount\n// is calculated and the treasury is treated as the remainder. This precision is important to\n// avoid off-by-one errors.\nexport function calculateFeePortions(amount: bigint): {\n  burnt: bigint;\n  treasury: bigint;\n} {\n  const burnt = (amount * 80n) / 100n; // 20% goes to treasury\n  return { burnt, treasury: amount - burnt };\n}\n\nexport interface TxWithEventAndFee extends TxWithEvent {\n  fee: RuntimeDispatchInfo | RuntimeDispatchInfoV1 | undefined;\n}\n\nexport interface BlockDetails {\n  block: Block;\n  txWithEvents: TxWithEventAndFee[];\n}\n\nexport interface BlockRangeOption {\n  from: number;\n  to: number;\n  concurrency?: number;\n}\n\nexport const getBlockExtrinsic = async (\n  api: ApiPromise,\n  blockHash: string | BlockHash,\n  section: string,\n  method: string\n): Promise<{\n  block: SignedBlock | any;\n  extrinsic: Extrinsic | null | any;\n  events: Event[];\n  resultEvent: Event | undefined;\n}> => {\n  const apiAt = await api.at(blockHash);\n  const [{ block }, records] = await Promise.all([\n    api.rpc.chain.getBlock(blockHash),\n    apiAt.query.system.events(),\n  ]);\n  const extIndex = block.extrinsics.findIndex(\n    (ext) => ext.method.section === section && ext.method.method === method\n  );\n  const extrinsic = extIndex > -1 ? block.extrinsics[extIndex] : null;\n  const events = (records as any)\n    .filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(extIndex))\n    .map(({ event }) => event);\n  const resultEvent = events.find(\n    (event) =>\n      event.section === \"system\" &&\n      (event.method === \"ExtrinsicSuccess\" || event.method === \"ExtrinsicFailed\")\n  );\n  return { block, extrinsic, events, resultEvent };\n};\n\nexport const getBlockTime = (signedBlock: any) =>\n  signedBlock.block.extrinsics\n    .find((item) => item.method.section === \"timestamp\")\n    .method.args[0].toNumber();\n\nexport const checkBlockFinalized = async (api: ApiPromise, number: number) => {\n  return {\n    number,\n    //@ts-expect-error - remove once pJs exposes this\n    finalized: await api._rpcCore.provider.send(\"moon_isBlockFinalized\", [\n      await api.rpc.chain.getBlockHash(number),\n    ]),\n  };\n};\n\nconst fetchBlockTime = async (api: ApiPromise, blockNum: number) => {\n  const hash = await api.rpc.chain.getBlockHash(blockNum);\n  const block = await api.rpc.chain.getBlock(hash);\n  return getBlockTime(block);\n};\n\nexport const fetchHistoricBlockNum = async (\n  api: ApiPromise,\n  blockNumber: number,\n  targetTime: number\n) => {\n  if (blockNumber <= 1) {\n    return 1;\n  }\n  const time = await fetchBlockTime(api, blockNumber);\n\n  if (time <= targetTime) {\n    return blockNumber;\n  }\n\n  return fetchHistoricBlockNum(\n    api,\n    blockNumber - Math.ceil((time - targetTime) / 30_000),\n    targetTime\n  );\n};\n\nexport const getBlockArray = async (\n  api: ApiPromise,\n  timePeriod: number,\n  bottleneck?: Bottleneck\n) => {\n  /**  \n  @brief Returns an sequential array of block numbers from a given period of time in the past\n  @param api Connected ApiPromise to perform queries on\n  @param timePeriod Moment in the past to search until\n  @param limiter Bottleneck rate limiter to throttle requests\n  */\n\n  let limiter = bottleneck;\n\n  if (!limiter) {\n    limiter = new Bottleneck({ maxConcurrent: 10, minTime: 100 });\n  }\n  const finalizedHead = await limiter.schedule(() => api.rpc.chain.getFinalizedHead());\n  const signedBlock: SignedBlock = await limiter.schedule(() =>\n    api.rpc.chain.getBlock(finalizedHead)\n  );\n\n  const lastBlockNumber = signedBlock.block.header.number.toNumber();\n  const lastBlockTime = getBlockTime(signedBlock);\n\n  const firstBlockTime = lastBlockTime - timePeriod;\n  debug(`Searching for the block at: ${new Date(firstBlockTime)}`);\n  const firstBlockNumber = (await limiter.wrap(fetchHistoricBlockNum)(\n    api,\n    lastBlockNumber,\n    firstBlockTime\n  )) as number;\n  const length = lastBlockNumber - firstBlockNumber;\n  return Array.from({ length }, (_, i) => firstBlockNumber + i);\n};\n\nexport function extractWeight(\n  weightV1OrV2: u64 | Option<u64> | SpWeightsWeightV2Weight | Option<any>\n) {\n  if (\"isSome\" in weightV1OrV2) {\n    const weight = weightV1OrV2.unwrap();\n    if (\"refTime\" in weight) {\n      return weight.refTime.unwrap();\n    }\n    return weight;\n  }\n  if (\"refTime\" in weightV1OrV2) {\n    return weightV1OrV2.refTime.unwrap();\n  }\n  return weightV1OrV2;\n}\n\nexport function extractPreimageDeposit(\n  request:\n    | Option<ITuple<any>>\n    | {\n        readonly deposit: ITuple<any>;\n        readonly len: u32;\n      }\n    | {\n        readonly deposit: Option<ITuple<any>>;\n        readonly count: u32;\n        readonly len: Option<u32>;\n      }\n) {\n  const deposit = \"deposit\" in request ? request.deposit : request;\n  if (\"isSome\" in deposit && deposit.isSome) {\n    return {\n      accountId: deposit.unwrap()[0].toHex(),\n      amount: deposit.unwrap()[1],\n    };\n  }\n  if (\"isNone\" in deposit && deposit.isNone) {\n    return undefined;\n  }\n  return {\n    accountId: deposit[0].toHex(),\n    amount: deposit[1],\n  };\n}\n\nexport function mapExtrinsics(\n  extrinsics: Extrinsic[],\n  records: FrameSystemEventRecord[],\n  fees?: RuntimeDispatchInfo[] | RuntimeDispatchInfoV1[]\n): TxWithEventAndFee[] {\n  return extrinsics.map((extrinsic, index): TxWithEventAndFee => {\n    let dispatchError: DispatchError | undefined;\n    let dispatchInfo: DispatchInfo | undefined;\n\n    const events = records\n      .filter(({ phase }) => phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index))\n      .map(({ event }) => {\n        if (event.section === \"system\") {\n          if (event.method === \"ExtrinsicSuccess\") {\n            dispatchInfo = event.data[0] as DispatchInfo;\n          } else if (event.method === \"ExtrinsicFailed\") {\n            dispatchError = event.data[0] as DispatchError;\n            dispatchInfo = event.data[1] as DispatchInfo;\n          }\n        }\n\n        return event;\n      });\n    return {\n      dispatchError,\n      dispatchInfo,\n      events,\n      extrinsic,\n      fee: fees ? fees[index] : undefined,\n    };\n  });\n}\n\nexport async function checkTimeSliceForUpgrades(\n  api: ApiPromise,\n  blockNumbers: number[],\n  currentVersion: u32\n) {\n  const apiAt = await api.at(await api.rpc.chain.getBlockHash(blockNumbers[0]));\n  const onChainRt = (await apiAt.query.system.lastRuntimeUpgrade()).unwrap().specVersion;\n  return { result: !onChainRt.eq(currentVersion), specVersion: onChainRt };\n}\n","import pino from \"pino\";\nimport type { Logger } from \"pino\";\nimport pinoPretty from \"pino-pretty\";\n\nexport interface LoggerOptions {\n  name: string;\n  level?: string;\n  enabled?: boolean;\n}\n\nconst logLevel = process.env.LOG_LEVEL || \"info\";\n\n// Create pretty stream for all contexts\nconst prettyStream = pinoPretty({\n  colorize: true,\n  translateTime: \"HH:MM:ss.l\",\n  ignore: \"pid,hostname\",\n  sync: true, // Important for worker threads\n});\n\nconst pinoOptions: pino.LoggerOptions = {\n  level: logLevel,\n  formatters: {\n    level: (label) => {\n      return { level: label };\n    },\n  },\n};\n\nconst loggers = new Map<string, Logger>();\n\nexport function createLogger(options: LoggerOptions): Logger {\n  const { name, level = logLevel, enabled = true } = options;\n\n  const existingLogger = loggers.get(name);\n  if (existingLogger) {\n    return existingLogger;\n  }\n\n  const loggerConfig: pino.LoggerOptions = {\n    name,\n    level,\n    enabled,\n    formatters: pinoOptions.formatters,\n  };\n\n  // Create logger with pretty stream\n  const logger = pino(loggerConfig, prettyStream);\n\n  loggers.set(name, logger);\n\n  return logger;\n}\n\nexport function getLogger(name: string): Logger | undefined {\n  return loggers.get(name);\n}\n\nexport function clearLoggers(): void {\n  loggers.clear();\n}\n\n// Helper function to enable/disable specific loggers\nexport function setLoggerEnabled(pattern: string, enabled: boolean): void {\n  const regex = new RegExp(pattern.replace(/\\*/g, \".*\"));\n\n  loggers.forEach((logger, name) => {\n    if (regex.test(name)) {\n      logger.level = enabled ? logLevel : \"silent\";\n    }\n  });\n}\n\n// Compatibility layer for the existing setupLogger function\nexport function setupLogger(name: string): pino.Logger {\n  const logger = createLogger({\n    name: `test:${name}`,\n    enabled: process.argv.includes(\"--printlogs\"),\n  });\n\n  return logger;\n}\n\n// Re-export types\nexport type { Logger } from \"pino\";\n"],"mappings":"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","names":["logger"]}